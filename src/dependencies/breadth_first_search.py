from dependencies.handlers import expand

from .enums import failure
from .node import Node
from .queue import FIFOQueue


def breadth_first_search(problem):
    """
    Выполняет поиск в ширину (Breadth-First Search, BFS) для решения
    заданной задачи.

    Алгоритм работает следующим образом:
    1. Создаётся начальный узел из начального состояния задачи.
    2. Если начальное состояние уже является целевым, алгоритм завершает
       работу и возвращает этот узел.
    3. Используется очередь FIFO для хранения узлов на границе (frontier),
       которые нужно исследовать.
    4. Используется множество reached для отслеживания посещённых состояний и
       предотвращения зацикливания.
    5. В цикле для каждого узла:
       - Проверяется, является ли его состояние целевым.
       - Если состояние узла ещё не было исследовано, оно добавляется в
         множество reached и очередь frontier.
    6. Если целевое состояние не найдено, возвращается значение failure.

    :param problem: Экземпляр задачи, содержащей:
                    - initial: начальное состояние,
                    - is_goal(state): метод проверки целевого состояния.
    :return: Узел, представляющий целевое состояние, либо константа failure,
     если решение не найдено.
    """
    # Инициализация начального узла с состоянием начальной задачи.
    node = Node(problem.initial)
    if problem.is_goal(
        problem.initial
    ):  # Проверяем, является ли начальное состояние целевым.
        return node  # Возвращаем узел, если цель достигнута.

    # Очередь для хранения узлов на границе (узлы, которые нужно исследовать).
    frontier = FIFOQueue([node])
    # Множество для отслеживания всех достигнутых (посещённых) состояний.
    reached = {problem.initial}

    # Основной цикл алгоритма поиска.
    while frontier:  # Выполняем, пока в очереди есть узлы.
        node = frontier.pop()  # Извлекаем узел из начала очереди (FIFO).
        for child in expand(problem, node):  # Генерируем дочерние узлы.
            s = child.state  # Состояние дочернего узла.
            if problem.is_goal(s):  # Если достигнута цель, возвращаем этот узел.
                return child
            if s not in reached:  # Если состояние ещё не исследовано:
                reached.add(s)  # Добавляем его в множество посещённых состояний.
                frontier.appendleft(child)  # Добавляем узел в начало очереди.

    # Если все возможные узлы исследованы и решение не найдено, возвращаем
    # failure.
    return failure
