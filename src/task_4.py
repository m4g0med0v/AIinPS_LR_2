#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Для построенного графа лабораторной работы 1
# (имя файла начинается с PR.AI.001.) напишите программу на языке
# программирования Python, которая с помощью алгоритма поиска в ширину
# находит минимальное расстояние между начальным и конечным пунктами. Сравните
# найденное решение с решением, полученным вручную.

from dependencies import (
    Problem,
    breadth_first_search,
    failure,
    path_actions,
    path_states,
)

graph = {
    "Гудермес": {"Шали": 35, "Курчалой": 19, "Хасавюрт": 45, "Буйнакск": 80},
    "Шали": {"Гудермес": 35, "Курчалой": 19, "Буйнакск": 70, "Избербаш": 60},
    "Курчалой": {
        "Шали": 19,
        "Гудермес": 19,
        "Ведено": 39,
        "Буйнакск": 55,
        "Тарумовка": 50,
    },
    "Ведено": {"Курчалой": 39, "Хасавюрт": 90, "Буйнакск": 100},
    "Хасавюрт": {
        "Гудермес": 45,
        "Ведено": 90,
        "Буйнакск": 60,
        "Леваши": 120,
        "Кизилюрт": 40,
        "Тарумовка": 75,
        "Сулак": 85,
    },
    "Буйнакск": {
        "Хасавюрт": 60,
        "Леваши": 64,
        "Шали": 70,
        "Курчалой": 55,
        "Ведено": 100,
        "Избербаш": 85,
        "Каспийск": 90,
        "Кизилюрт": 50,
        "Тарумовка": 45,
        "Сулак": 78,
        "Гудермес": 80,
    },
    "Леваши": {
        "Буйнакск": 64,
        "Хасавюрт": 120,
        "Избербаш": 75,
        "Каспийск": 55,
    },
    "Избербаш": {"Шали": 60, "Буйнакск": 85, "Леваши": 75, "Каспийск": 30},
    "Каспийск": {"Избербаш": 30, "Буйнакск": 90, "Леваши": 55, "Кизилюрт": 60},
    "Кизилюрт": {"Хасавюрт": 40, "Буйнакск": 50, "Каспийск": 60},
    "Тарумовка": {"Хасавюрт": 75, "Буйнакск": 45, "Курчалой": 50},
    "Сулак": {"Буйнакск": 78, "Кизилюрт": 63, "Хасавюрт": 85},
}


# Создадим конкретную задачу, наследуя Problem
class SimpleGraphProblem(Problem):
    def __init__(self, initial, goal, graph, **kwds):
        # Инициализация задачи с начальным и целевым состоянием, а также графом
        super().__init__(initial, goal, **kwds)
        self.graph = graph

    def actions(self, state):
        """Возвращает список всех доступных переходов для данного состояния"""
        # Возвращаем все соседние города
        return self.graph.get(state, {})

    def result(self, state, action):
        """Возвращает новое состояние при применении действия"""
        # Переход в указанный соседний город
        return action

    def action_cost(self, s, a, s1):
        """Стоимость действия - в этом случае всегда 1"""
        # Стоимость перехода (расстояние между городами)
        return 1


if __name__ == "__main__":
    # Начальное и целевое состояние задачи
    initial_state = "Шали"
    goal_state = "Леваши"

    # Создаем объект задачи
    problem = SimpleGraphProblem(initial=initial_state, goal=goal_state, graph=graph)

    # Используем поиск в ширину для нахождения решения
    solution_node = breadth_first_search(problem)

    if solution_node != failure:
        path = path_states(solution_node)
        actions = path_actions(solution_node)
        print(f"Путь до цели: {path}")
        print(f"Действия: {actions}")
    else:
        print("Решение не найдено.")
